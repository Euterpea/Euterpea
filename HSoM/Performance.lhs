%-*- mode: Latex; abbrev-mode: true; auto-fill-function: do-auto-fill -*-

%include lhs2TeX.fmt
%include myFormat.fmt

\out{
\begin{code}
-- This code was automatically generated by lhs2tex --code, from the file 
-- HSoM/Performance.lhs.  (See HSoM/MakeCode.bat.)

\end{code}
}

\chapter{Interpretation and Performance}
\label{ch:performance}

\begin{code}
{-# LANGUAGE FlexibleInstances, TypeSynonymInstances #-}

module Euterpea.Music.Note.Performance
       where

import Euterpea.Music.Note.Music
import Euterpea.Music.Note.MoreMusic

instance Show (a -> b) where
   showsPrec p f = showString "<<function>>"
\end{code} 

\section{Abstract Performance}
\label{sec:performance}

So far, our presentation of musical values in Haskell has been
entirely structural, i.e.\ \emph{syntactic}.  But what do these
musical values actually \emph{mean}, i.e.\ what is their
\emph{semantics}, or \emph{interpretation}?  The formal process of
giving a semantic interpretation to syntactic constructs is very
common in computer science, especially in programming language theory.
But it is obviously also common in music: the interpretation of music
is the very essence of musical performance.  However, in conventional
music this process is usually informal, appealing to aesthetic
judgments and values.  What we would like to do is make the process
formal in Euterpea---but still flexible, so that more than one
interpretation is possible, just as in music.

To begin, we need to say exactly what an abstract \emph{performance}
is.  Our approach is to consider a performance to be a time-ordered
sequence of musical \emph{events}, where each event captures the
playing of one individual note.  In Haskell:
\begin{code}

type Performance = [Event]

data Event = Event {  eTime    :: PTime, 
                      eInst    :: InstrumentName, 
                      ePitch   :: AbsPitch,
                      eDur     :: DurT, 
                      eVol     :: Volume, 
                      eParams  :: [Double]}
     deriving (Eq,Ord,Show)
\end{code}
\begin{spec}
type PTime     = Rational
type DurT      = Rational
type Volume    = Integer
\end{spec}
\out{
\begin{code}
type PTime     = Rational
type DurT      = Rational
\end{code}}

\index{field labels} 
\syn{The data declaration for |Event| uses Haskell's \emph{field
    label} syntax, also called \emph{record} syntax, and is equivalent to:
\begin{spec}
data Event = Event  PTime InstrumentName 
                    AbsPitch DurT Volume [Float]
     deriving (Eq,Ord,Show)
\end{spec}
except that the former also defines ``field labels'' |eTime|, |eInst|, 
|ePitch|, |eDur|, |eVol|, and |eParams|, which can be used to
create, update, and select from |Event| values.  For example, this
equation: 
\begin{spec}
e = Event 0 Cello 27 (1/4) 50 []
\end{spec}
is equivalent to:
\begin{spec}
e = Event {  eTime = 0, ePitch = 27, eDur = 1/4, 
             eInst = Cello, eVol = 50, eParams = [] }
\end{spec}
Although more verbose, the latter is also more descriptive, and the
order of the fields does not matter (indeed the order here is not the
same as above).
%% this equation would do just as well:
%% \begin{spec}
%% e = Event { eDur = 1/4, eVol = 50, eParams = [],
%%             eTime = 0, eInst = Cello, ePitch = 27 }
%% \end{spec}
%% The use of field labels in a data declaration does not preclude the
%% positional style of field access.
}

\syn{Field labels can be used to \emph{select} fields from an |Event|
value; for example, using the value of |e| above, |eInst e => Cello|,
|eDur e => 1/4|, and so on.  They can also be used to selectively
\emph{update} fields of an existing |Event| value.  For example:
\begin{spec}
e { eInst = Flute } ==> Event 0 Flute 27 (1/4) 50 []
\end{spec}
Finally, they can be used selectively in pattern matching:
\begin{spec}
f (Event { eDur = d, ePitch = p }) = ... d ... p ...
\end{spec}
Field labels do not change the basic nature of a data type; they are
simply a convenient syntax for referring to the components of a data
type by name rather than by position.}

An event |Event {eTime = s, eInst = i, ePitch = p, eDur = d, eVol = v}|
captures the fact that at start time |s|, instrument |i| sounds pitch
|p| with volume |v| for a duration |d| (where now duration is measured
in seconds, rather than beats).  (The |pField| of an event is for
special instruments that require extra parameters, and will not be
discussed much further in this chapter.)

An abstract performance is the lowest of our music representations not
yet committed to MIDI, csound, or some other low-level computer music
representation.  In Chapter \ref{ch:midi} we will discuss how to map a
performance into MIDI.

To generate a complete performance of, i.e.\ give an interpretation
to, a musical value, we must know the time to begin the performance,
and the proper instrument, volume, key and tempo.  In addition, to
give flexibility to our interpretations, we must also know what {\em
  player} to use; that is, we need a mapping from the |PlayerName|s in
a |Music| value to the actual players to be used.\footnote{We don't
  need a mapping from |InstrumentNames| to instruments, since this is
  handled in the translation from a performance into MIDI, which
  is discussed in Chapter \ref{ch:midi}.}  
We capture these ideas in Haskell as a ``context'' and ``player map,''
respectively:
%% as defined in Section \ref{midi}.)
\begin{code}

data Context a = Context {  cTime    :: PTime, 
                            cPlayer  :: Player a, 
                            cInst    :: InstrumentName, 
                            cDur     :: DurT, 
                            cKey     :: Key, 
                            cVol     :: Volume}
     deriving Show
type PMap a  = PlayerName -> Player a
type Key     = AbsPitch
\end{code}

Finally, we are ready to give an interpretation to a piece of music,
which we do by defining a function |perform|, which is conceptually
perhaps the most important function defined in this book, and is shown
in Figure \ref{fig:perform}.

\begin{figure}
\begin{spec}
perform :: PMap a -> Context a -> Music a -> Performance
perform pm 
  c@Context {cTime = t, cPlayer = pl, cDur = dt, cKey = k} m =
  case m of
     Prim (Note d p)           ->  playNote pl c d p
     Prim (Rest d)             ->  []
     m1 :+: m2                 ->  
               let c' = c {cTime = t + dur m1 * dt}
               in  perform pm c m1 ++ perform pm c' m2
     m1 :=: m2                 ->  merge   (perform pm c m1) 
                                           (perform pm c m2)
     Modify  (Tempo r) m       ->  perform pm (c {cDur = dt / r}) m
     Modify  (Transpose p) m   ->  perform pm (c {cKey = k + p}) m
     Modify  (Instrument i) m  ->  perform pm (c {cInst = i}) m
     Modify  (Player pn) m -> perform pm (c {cPlayer = pm pn}) m
     Modify  (Phrase pa) m     ->  interpPhrase pl pm c pa m
\end{spec}
\caption{An abstract |perform| function}
\label{fig:perform}
\end{figure}

%%     m1 :=/ m2                 ->  mergeS  (perform pm c m1) 
%%                                           (perform pm c m2)

Some things to note about |perform|:
\begin{enumerate} 
\item
The |Context| is the running ``state'' of the performance, and
gets updated in several different ways.  For example, the
interpretation of the |Tempo| constructor involves scaling
|dt| appropriately and updating the |DurT| field of the context.

\item
The interpretation of notes and phrases is player dependent.
Ultimately a single note is played by the |playNote| function, which
takes the player as an argument.  Similarly, phrase interpretation is
also player dependent, reflected in the use of |interpPhrase|.
Precisely how these two functions work is described in Section
\ref{players}.

\item
The |DurT| component of the context is the duration, in seconds,
of one whole note.  To make it easier to compute, we can define a
``metronome'' function that, given a standard metronome marking (in
beats per minute) and the note type associated with one beat (quarter
note, eighth note, etc.)  generates the duration of one whole note:
\begin{code}
metro              :: Int -> Dur -> DurT
metro setting dur  = 60 / (fromIntegral setting * dur)
\end{code} 
Thus, for example, |metro 96 qn| creates a tempo of 96 quarter
notes per minute.

\syn{|fromIntegral :: (Integral a, Num b) => a -> b| coerces a value
  whose type is a member of the |Integral| class to a value whose type
  is a member of the |Num| class.  As used here, it is effectively
  converting the |Int| value |setting| to a |Rational| value, because
  |dur| is a |Rational| value, |Rational| is a member of the |Num|
  class, and multiplication has type |(*) :: Num a => a->a->a|.}

\item
In the treatment of |(:+:)|, note that the sub-sequences are appended
together, with the start time of the second argument delayed by the
duration of the first.  The function |dur| (defined in Section
\ref{sec:duration}) is used to compute this duration.  However, this
results in a quadratic time complexity for |perform|.  A more
efficient solution is to have |perform| compute the duration directly,
returning it as part of its result.  This version of |perform| is
shown in Figure \ref{fig:real-perform}.

\item
The sub-sequences derived from the arguments to |(:=:)| are merged
into a time-ordered stream.  The definition of |merge| is given below.

\begin{spec}
merge :: Performance -> Performance -> Performance

merge a@(e1:es1)  b@(e2:es2)  =  if e1 < e2  
                                 then e1 : merge es1 b
                                 else e2 : merge a es2
merge []          es2         =  es2
merge es1         []          =  es1
\end{spec} 

Note that |merge| compares entire events rather than just start times.
This is to ensure that it is commutative, a desirable condition for
some of the proofs used later in the text.  

\newpage

Here is a more efficient version of |merge| that will work just as
well in practice:
\begin{code}

merge a@(e1:es1)  b@(e2:es2)  =  if eTime e1 < eTime e2
                                 then e1 : merge es1 b
                                 else e2 : merge a es2
merge []          es2         =  es2
merge es1         []          =  es1
\end{code} 
\end{enumerate} 

\out{
Let's represent numbers as a non-empty list of monotonically
increasing numbers whose last number is the limit:

newtype ANum a = ANum [a]
  deriving (Eq, Show)

instance Num a => Num (ANum a) where
  ANum xs + ANum ys = ANum (nLift (+) xs ys)
--ANum xs - ANum ys = ANum (nLift (-) xs ys)   -- not valid!!!
  ANum xs - ANum ys = ANum (nSub xs ys)
  ANum xs * ANum ys = ANum (nLift (*) xs ys)
  abs (ANum xs)     = ANum (map abs xs)
  signum (ANum xs)  = ANum (map signum xs)
  fromInteger x     = ANum [fromInteger x]
  
nLift op [x] ys        = map (x `op`) ys
nLift op xs [y]        = map (`op` y) xs
nLift op (x:xs) (y:ys) = (x `op` y) : nLift op xs ys

nSub [x] ys = map (x-) ys
nSub xs [y] = map (subtract y) xs
nSub (x:xs) (y:ys) = nSub xs ys

ANum [x] =* ANum [y] = x == y
ANum (x:xs) =* ANum (y:ys) = ANum xs =* ANum ys

ANum [x] >* ANum (y:ys)    = if x<=y then False else ANum [x] >* ANum ys
ANum (x:xs) >* ANum [y]    = if x>y  then True  else ANum xs >* ANum [y]
ANum (x:xs) >* ANum (y:ys) = ANum xs >* ANum ys

an1 >=* an2 = an1 >* an2 || an1 =* an2
an1 <*  an2 = not (an1 >=* an2)
an1 <=* an2 = not (an1 >* an2)

The reason that subtraction cannot be handled like addition or
multiplication is that, if one number is at least x and another number
is at least y, we cannot conclude ANYTHING about the difference
between them.

Here are the merge functions for the parallel short constructor:

mergeS :: Performance -> Performance -> Performance

mergeS a@(e1:es1)) b@(e2:es2)) = 
  if e1 < e2 then foo e1 es1 b
             else foo e2 a es2
merge [] es2 = []
merge es1 [] = []

foo e es1 es2 =
  let pf  = mergeS es1 es2
      dft = eTime (head pf) - eTime e
      d  = min (eDur e) (aDur pf + dft)
  in e { eDur = d } : pf


aDur es = Anum (foo 0 es)
  where foo d []     = d
        foo d (e:es) = 
}

\begin{figure}
\begin{code}

perform :: PMap a -> Context a -> Music a -> Performance
perform pm c m = fst (perf pm c m)

perf :: PMap a -> Context a -> Music a -> (Performance, DurT)
perf pm 
  c@Context {cTime = t, cPlayer = pl, cDur = dt, cKey = k} m =
  case m of
     Prim (Note d p)            -> (playNote pl c d p, d*dt)
     Prim (Rest d)              -> ([], d*dt)
     m1 :+: m2                  ->  
             let  (pf1,d1)  = perf pm c m1
                  (pf2,d2)  = perf pm (c {cTime = t+d1}) m2
             in (pf1++pf2, d1+d2)
     m1 :=: m2                  -> 
             let  (pf1,d1)  = perf pm c m1
                  (pf2,d2)  = perf pm c m2
             in (merge pf1 pf2, max d1 d2)
     Modify  (Tempo r) m        -> perf pm (c {cDur = dt / r}) m
     Modify  (Transpose p) m    -> perf pm (c {cKey = k + p}) m
     Modify  (Instrument i) m   -> perf pm (c {cInst = i}) m
     Modify  (Player pn) m      -> perf pm (c {cPlayer = pm pn}) m
     Modify  (Phrase pas) m     -> interpPhrase pl pm c pas m
\end{code}
\caption{A more efficient |perform| function}
\label{fig:real-perform}
\end{figure}

%%      m1 :=/ m2                  -> 
%%              let  (pf1,d1) = perf pm c m1
%%                   (pf2,d2) = perf pm c m2
%%              in (merge pf1 pf2, max d1 d2)

\newpage

\section{Players}
\label{players}

%% \begin{spec}
%% module Players (module Players, module Music, module Performance)
%%        where
%% import Music
%% import Performance
%% \end{spec} 

Recall from Section \ref{sec:music} the definition of the |Control|
data type:
\begin{spec}
data Control =
          Tempo       Rational           -- scale the tempo
       |  Transpose   AbsPitch           -- transposition
       |  Instrument  InstrumentName     -- intrument label
       |  Phrase      [PhraseAttribute]  -- phrase attributes
       |  Player      PlayerName         -- player label
     deriving (Show, Eq, Ord)

type PlayerName = String
\end{spec}
We mentioned, but did not define, the |PhraseAttribute| data type,
shown now fully in Figure \ref{fig:phrase-attributes}.  These
attributes give us great flexibility in the interpretation process,
because they can be interpreted by different players in different
ways.  For example, how should ``legato'' be interpreted in a
performance?  Or ``diminuendo?''  Different players interpret things
in different ways, of course, but even more fundamental is the fact
that a pianist, for example, realizes legato in a way fundamentally
different from the way a violinist does, because of differences in
their instruments.  Similarly, diminuendo on a piano and diminuendo on
a harpsichord are different concepts.

\begin{figure}{\small
\begin{spec}
data PhraseAttribute  =  Dyn Dynamic
                      |  Tmp Tempo
                      |  Art Articulation
                      |  Orn Ornament
     deriving (Eq, Ord, Show)

data Dynamic  =  Accent Rational | Crescendo Rational
              |  Diminuendo Rational | StdLoudness StdLoudness 
              |  Loudness Rational
     deriving (Eq, Ord, Show)

data StdLoudness = PPP | PP | P | MP | SF | MF | NF | FF | FFF
     deriving (Eq, Ord, Show, Enum)

data Tempo = Ritardando Rational | Accelerando Rational
     deriving (Eq, Ord, Show)

data Articulation  =  Staccato Rational | Legato Rational 
                   |  Slurred Rational | Tenuto | Marcato | Pedal 
                   |  Fermata | FermataDown | Breath | DownBow 
                   |  UpBow | Harmonic | Pizzicato | LeftPizz 
                   |  BartokPizz | Swell | Wedge | Thumb | Stopped
     deriving (Eq, Ord, Show)

data Ornament  =  Trill | Mordent | InvMordent | DoubleMordent
               |  Turn | TrilledTurn | ShortTrill
               |  Arpeggio | ArpeggioUp | ArpeggioDown
               |  Instruction String | Head NoteHead
     deriving (Eq, Ord, Show)

data NoteHead  =  DiamondHead | SquareHead | XHead | TriangleHead
               |  TremoloHead | SlashHead | ArtHarmonic | NoHead
     deriving (Eq, Ord, Show)
\end{spec}}
\caption{Phrase Attributes}
\label{fig:phrase-attributes}
\end{figure}

With a slight stretch of the imagination, we can even consider a
``notator'' of a score as a kind of player: exactly how the music is
rendered on the written page may be a personal, stylized process.  For
example, how many, and which staves should be used to notate a
particular instrument?

In any case, to handle these issues, Euterpea has a notion of a
\emph{player} that ``knows'' about differences with respect to
performance and notation.  A Euterpea player is a 4-tuple consisting of
a name and three functions: one for interpreting notes, one for
phrases, and one for producing a properly notated score.
\begin{code}
data Player a = MkPlayer {  pName         :: PlayerName, 
                            playNote      :: NoteFun a,
                            interpPhrase  :: PhraseFun a, 
                            notatePlayer  :: NotateFun a }
     deriving Show

type NoteFun a    =  Context a -> Dur -> a -> Performance
type PhraseFun a  =  PMap a -> Context a -> [PhraseAttribute]
                     -> Music a -> (Performance, DurT)
type NotateFun a  =  ()
\end{code}
Note that |NotateFun| is just the unit type; this is because notation
is currently not implemented in Euterpea.

\subsection{Example of Player Construction}

In this section we define a ``default player'' called |defPlayer| (not
to be confused with a ``deaf player''!) for use when none other is
specified in a score; it also functions as a basis from which other
players can be derived.

In order to provide the most flexibility, we exploit poymorphism to
define a version of |Music| that in addition to pitch, carries a list
of ``note attributes'' for each individual note:
\begin{spec}
data NoteAttribute = 
        Volume  Int   -- MIDI convention: 0=min, 127=max
     |  Fingering Integer
     |  Dynamics String
     |  Params [Double]
   deriving (Eq, Show)
\end{spec}
Our goal then is to define a player for music values of type:
\begin{code}
type Music1  = Music Note1
type Note1   = (Pitch, [NoteAttribute])
\end{code}

\out{
Convert from Music to Music1:
\begin{code}

toMusic1 :: Music Pitch -> Music1
toMusic1 = mMap (\p -> (p, []))
\end{code}

Convert from Music(Pitch, Volume) to Music1:

\begin{code}
toMusic1' :: Music (Pitch, Volume) -> Music1
toMusic1' = mMap (\(p, v) -> (p, [Volume v]))
\end{code}
}

At the upper-most level, |defPlayer| is defined as a four-tuple:
\begin{code}
defPlayer  :: Player Note1
defPlayer  = MkPlayer 
             {  pName         = "Default",
                playNote      = defPlayNote      defNasHandler,
                interpPhrase  = defInterpPhrase  defPasHandler,
                notatePlayer  = () }
\end{code}

The remaining functions are defined in Figure
\ref{fig:default-Player}.  Before reading this code, first review how
players are invoked by the |perform| function defined in the last
section; in particular, note the calls to |playNote| and
|interpPhrase|.  We will define |defPlayer| to respond only to the
|Volume| note attribute and to the |Accent|, |Staccato|, and |Legato|
phrase attributes.

\begin{figure}
\begin{code}
defPlayNote ::  (Context (Pitch,[a]) -> a -> Event-> Event)
                -> NoteFun (Pitch, [a])
defPlayNote nasHandler 
  c@(Context cTime cPlayer cInst cDur cKey cVol) d (p,nas) =
    let initEv = Event {  eTime    = cTime, eInst  = cInst,
                          ePitch   = absPitch p + cKey,
                          eDur     = d * cDur, eVol = cVol,
                          eParams  = [] }
    in [ foldr (nasHandler c) initEv nas ]

defNasHandler :: Context a -> NoteAttribute -> Event -> Event
defNasHandler c (Volume v)     ev = ev {eVol = v}
defNasHandler c (Params pms)   ev = ev {eParams = pms}
defNasHandler _            _   ev = ev

defInterpPhrase :: 
   (PhraseAttribute -> Performance -> Performance) -> PhraseFun a
defInterpPhrase pasHandler pm context pas m =
       let (pf,dur) = perf pm context m
       in (foldr pasHandler pf pas, dur)

defPasHandler :: PhraseAttribute -> Performance -> Performance
defPasHandler (Dyn (Accent x))    = 
    map (\e -> e {eVol = round (x * fromIntegral (eVol e))})
defPasHandler (Art (Staccato x))  = 
    map (\e -> e {eDur = x * eDur e})
defPasHandler (Art (Legato   x))  = 
    map (\e -> e {eDur = x * eDur e})
defPasHandler _                   = id
\end{code} 
\caption{Definition of default player |defPlayer|.}
\label{fig:default-Player}
\end{figure}

% defNotatePlayer   :: a -> ()
% defNotatePlayer _ = ()

Then note:
\begin{enumerate} 
\item |defPlayNote| is the only function (even in the definition
of |perform|) that actually generates an event.  It also modifies
that event based on an interpretation of each note attribute by the
function |defNasHandler|.

\item  |defNasHandler| only recognizes the |Volume| attribute,
which it uses to set the event volume accordingly.

\item |defInterpPhrase| calls (mutually recursively)
|perform| to interpret a phrase, and then modifies the result based on
an interpretation of each phrase attribute by the function
|defPasHandler|.

\item |defPasHandler| only recognizes the |Accent|,
|Staccato|, and |Legato| phrase attributes.  For each of these it
uses the numeric argument as a ``scaling'' factor of the volume (for
|Accent|) and duration (for |Staccato| and |Legato|).  Thus 
|Modify (Phrase [Legato (5/4)]) m| effectively increases the duration
of each note in |m| by 25\% (without changing the tempo).
\end{enumerate} 

\subsection{Deriving New Players From Old Ones}
\label{sec:new-player}

It should be clear that much of the code in Figure
\ref{fig:default-Player} can be re-used in defining a new player.
For example, to define a player |newPlayer| that interprets note
attributes just like |defPlayer| but behaves differently with
respect to certain phrase attributes, we could write:
\begin{spec}
newPlayer :: Player (Pitch, [NoteAttribute])
newPlayer = MkPlayer 
            {  pName         = "NewPlayer",
               playNote      = defPlayNote defNasHandler,
               interpPhrase  = defInterpPhrase myPasHandler,
               notatePlayer  = () }
\end{spec} 
and then supply a suitable definition of |myPasHandler|.  Better yet,
we could just do this:
\begin{spec}
newPlayer :: Player (Pitch, [NoteAttribute])
newPlayer = defPlayer
            {  pName         = "NewPlayer",
               interpPhrase  = defInterpPhrase myPasHandler }
\end{spec} 
This version uses the ``record update'' syntax to directly derive the
new player from |defPlayer|.

The definition of |myPasHandler| can also re-use code, in the
following sense: suppose we wish to add an interpretation for
|Crescendo|, but otherwise have |myPasHandler| behave just like
|defPasHandler|.
\begin{spec}
myPasHandler :: PhraseAttribute -> Performance -> Performance
myPasHandler (Dyn (Crescendo x))  pf = ...
myPasHandler  pa                  pf = defPasHandler pa pf
\end{spec} 

\todo{Expain more... in particular, how ``inheritance'' works.}

\subsection{A Fancy Player}
\label{sec:fancy-player}

Figure \ref{fancy-Player} defines a relatively sophisticated player
called |fancyPlayer| that knows all that |defPlayer| knows, and more.
Note that |Slurred| is different from |Legato| in that it doesn't
extend the duration of the {\em last} note(s).  The behavior of
|Ritardando x| can be explained as follows.  We'd like to ``stretch''
the time of each event by a factor from $0$ to $x$, linearly
interpolated based on how far along the musical phrase the event
occurs.  I.e., given a start time $t_0$ for the first event in the
phrase, total phrase duration $D$, and event time $t$, the new event
time $t'$ is given by:
\[ t'   = (1 + \frac{t-t_0}{D}x)(t-t_0) + t_0 \]
Further, if $d$ is the duration of the event, then the end of
the event $t+d$ gets stretched to a new time $t_d'$ given by:
\[ t_d' = (1 + \frac{t+d-t_0}{D}x)(t+d-t_0) + t_0 \]
The difference $t_d' - t'$ gives us the new, stretched duration $d'$,
which after simplification is:
\[ d' = (1 + \frac{2(t-t_0)+d}{D}x)\ d \]
|Accelerando| behaves in exactly the same way, except that it
shortens event times rather than lengthening them.  And a similar but
simpler strategy explains the behaviors of |Crescendo| and
|Diminuendo|.

\section{Putting it all Together}

The |play| function in Euterpea ueses a default player map and a
default context that are defined as follows:
\begin{code}

defPMap            :: PMap Note1  -- = PlayerName -> Player Note1
defPMap "Fancy"    = fancyPlayer
defPMap "Default"  = defPlayer
defPMap n          = defPlayer { pName = n }

defCon  :: Context Note1
defCon  = Context {  cTime    = 0,
                     cPlayer  = fancyPlayer,
                     cInst    = AcousticGrandPiano,
                     cDur     = metro 120 qn,
                     cKey     = 0,
                     cVol     = 127 }
\end{code}
Note that if anything other than a |"Fancy"| player is specified in
the |Music| value, such as |player "Strange" m|, then the default
player |defPlayer| is used.

If instead one wishes to use her own player, say |newPlayer| defined
in Section \ref{sec:new-player}, then a new player map can be defined,
such as:
\begin{spec}
myPMap              :: PlayerName -> Player Note1
myPMap "NewPlayer"  = newPlayer
myPMap p            = defPMap p
\end{spec}

Similarly, different versions of the context can be defined based on a
user's needs.

One could, then, use these versions of player maps and contexts to
invoke the |perform| function to generate an abstract |Performance|.
Of course, we ultimately want to hear our music, not just see an
abstract |Performance|.  Recall that |play|'s type signature is:
\begin{spec}
play :: Performable a => Music a -> IO ()
\end{spec}
To allow using different player maps and contexts, Eutperpea also has
a version of |play| called |playA| whose type signature is:
\begin{spec}
playA ::  Performable a => 
          PMap Note1 -> Context Note1 -> Music a -> IO ()
\end{spec}
For example, to play a |Music| value |m| using |myPMap| defined above
and the default context |defCon|, one can do:
\begin{spec}
playA myPMap defCon m
\end{spec}

In later chapters we will learn more about |play|, and how it converts
a |Performance| into MIDI events that eventually are heard through
your computer's sound card.

\vspace{.1in}\hrule

\begin{exercise}{\em
Fill in the |...| in the definition of |myPasHandler| according to the
following strategy: Gradually scale the volume of each event in the
performance by a factor of |1| through |1+x|, using linear
interpolation.}
\end{exercise}

\begin{exercise}{\em
Choose some of the other phrase attributes and provide interpretations
for them.}
%% such as |Diminuendo|, |Slurred|, |Trill|, etc.  (The |trill|
%% functions from section \ref{sec:trills} may be useful here.)
\end{exercise}

\begin{exercise}{\em
Define a player |myPlayer| that appropriately handles the
|Pedal| articulation and both the |ArpeggioUp| and |ArpeggioDown|
ornamentations.  You should define |myPlayer| as a derivative
of |defPlayer|.}
\end{exercise}

\begin{exercise}{\em
%% Define a function |jazzMan| (or |jazzWoman| if you prefer) whose type
%% is |Music1 -> Music1| such that |jazzMan m| is the melody |m| modified to
%% reflect a jazz ``swing'' rhythm.

%% Should |jazzMan| instead be defined as a player?  Discuss.

Define a player |jazzMan| (or |jazzWoman| if you prefer) that plays a
melody using a jazz ``swing'' feel.  Since there are different kinds
and degrees of swing, we can be more specific as follows: whenever
there is a sequence of two eighth notes, they should be interpreted
instead as a quarter note followed by an eighth note, but with tempo
3/2.  So in essence, the first note is lengthened, and the second note
is shortened, so that the first note is twice as long as the second,
but they still take up the same amount of overall time.

To do this at the |Player| level, some assumptions need to be made, such as
what is an eighth note, where is the downbeat, etc.\
}
\end{exercise}

\vspace{.1in}\hrule
\vspace{.1in}

\begin{figure}
\todo{This code has errors and needs to be fixed.}
{\small
\begin{code}

fancyPlayer :: Player (Pitch, [NoteAttribute])
fancyPlayer  = MkPlayer {  pName         = "Fancy",
                           playNote      = defPlayNote defNasHandler,
                           interpPhrase  = fancyInterpPhrase,
                           notatePlayer  = () }

fancyInterpPhrase             :: PhraseFun a
fancyInterpPhrase pm c [] m   = perf pm c m
fancyInterpPhrase pm 
  c@Context {  cTime = t, cPlayer = pl, cInst = i, 
               cDur = dt, cKey = k, cVol = v}
  (pa:pas) m =
  let  pfd@(pf,dur)  =  fancyInterpPhrase pm c pas m
       loud x        =  fancyInterpPhrase pm c (Dyn (Loudness x) : pas) m
       stretch x     =  let  t0 = eTime (head pf);  r  = x/dur
                             upd (e@Event {eTime = t, eDur = d}) = 
                               let  dt  = t-t0
                                    t'  = (1+dt*r)*dt + t0
                                    d'  = (1+(2*dt+d)*r)*d
                               in e {eTime = t', eDur = d'}
                        in (map upd pf, (1+x)*dur)
       inflate x     =  let  t0  = eTime (head pf);  
                             r   = x/dur
                             upd (e@Event {eTime = t, eVol = v}) = 
                                 e {eVol =  round ( (1+(t-t0)*r) * 
                                            fromIntegral v)}
                        in (map upd pf, dur)
  in case pa of
    Dyn (Accent x) ->
        ( map (\e-> e {eVol = round (x * fromIntegral (eVol e))}) pf, dur)
    Dyn (StdLoudness l) -> 
        case l of 
           PPP  -> loud 40;       PP -> loud 50;   P    -> loud 60
           MP   -> loud 70;       SF -> loud 80;   MF   -> loud 90
           NF   -> loud 100;      FF -> loud 110;  FFF  -> loud 120
    Dyn (Loudness x)     ->  fancyInterpPhrase pm c 
                             {cVol = (round . fromRational) x} pas m
    Dyn (Crescendo x)    ->  inflate   x ; Dyn (Diminuendo x)  -> inflate (-x)
    Tmp (Ritardando x)   ->  stretch   x ; Tmp (Accelerando x) -> stretch (-x)
    Art (Staccato x)     ->  (map (\e-> e {eDur = x * eDur e}) pf, dur)
    Art (Legato x)       ->  (map (\e-> e {eDur = x * eDur e}) pf, dur)
    Art (Slurred x)      -> 
        let  lastStartTime  = foldr (\e t -> max (eTime e) t) 0 pf
             setDur e       =   if eTime e < lastStartTime
                                then e {eDur = x * eDur e}
                                else e
        in (map setDur pf, dur) 
    Art _                -> pfd
    Orn _                -> pfd
\end{code}}
\todo{Design Bug: To do things right we need to keep the key signature
      around to determine, for example, what the trill note is.
      Alternatively, provide an argument to Trill to carry this info.}
\caption{Definition of Player |fancyPlayer|.}
\label{fancy-Player}
\end{figure}

\out{

Generating Performances
-----------------------

Make the default translation to Performance as a class in order to deal
with both Music Pitch and Music Note1:

\begin{code}

class Performable a where
  perfDur :: PMap Note1 -> Context Note1 -> Music a -> (Performance, DurT)
\end{code}

Using the defaults below, from a Music value we can generate a
Performance:

\begin{code}

instance Performable Note1 where
  perfDur pm c m = perf pm c m

instance Performable Pitch where
  perfDur pm c = perfDur pm c . toMusic1

instance Performable (Pitch, Volume) where
  perfDur pm c = perfDur pm c . toMusic1'

defToPerf :: Performable a => Music a -> Performance
defToPerf = fst . perfDur defPMap defCon

toPerf :: Performable a => PMap Note1 -> Context Note1 -> Music a -> Performance
toPerf pm con = fst . perfDur pm con
\end{code}

}
